import asyncio
import os
import random
from datetime import datetime
from pathlib import Path
from typing import List
import logging

from dotenv import load_dotenv
from faker import Faker
from pydantic import BaseModel, EmailStr, Field
from slugify import slugify
from reportlab.lib import colors
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import inch
from reportlab.platypus import Image as RLImage, Paragraph, SimpleDocTemplate, Spacer
from reportlab.lib.styles import ParagraphStyle, getSampleStyleSheet

from agents import Agent, Runner
from utils.avatars import generate_avatar

# ---------------- Configuration ----------------
load_dotenv()

MODEL = os.getenv("OPENAI_CV_MODEL", "gpt-5-nano")
CVS_OUTPUT_DIR = Path(os.getenv("CVS_OUTPUT_DIR", "cvs"))

# Candidate variability parameters
INDUSTRIES = ["Fintech", "Healthcare", "Gaming", "E-commerce", "IoT", "AI/ML",
              "Logistics", "Education", "MarTech", "ClimateTech"]
LEVELS = ["junior", "mid-level", "senior", "lead"]
PRIMARY_STACKS = [
    "Python + FastAPI + PostgreSQL + Docker",
    "TypeScript + React + Node.js + PostgreSQL",
    "Java + Spring Boot + Kafka + Redis",
    "Go + gRPC + Kubernetes + Prometheus",
    "Rust + Actix + Postgres + Nix",
    "Swift/Kotlin + Mobile CI/CD",
    "TensorFlow/PyTorch + Airflow + ML Ops",
]

# Silence OpenAI/httpx noisy INFO logs
logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("openai").setLevel(logging.WARNING)

fake = Faker()


# ---------------- Pydantic schemas ----------------
class Experience(BaseModel):
    """Represents one job experience entry in the CV."""
    role: str
    company: str
    start: str  # Format: "Month YYYY"
    end: str  # Either "Present" or "Month YYYY"
    description: str


class Education(BaseModel):
    """Represents education background for the CV."""
    degree: str
    university: str
    year: int = Field(..., ge=2010, le=datetime.now().year - 1)


class CVTech(BaseModel):
    """Schema for the technical part of a CV generated by the LLM."""
    role: str
    skills: List[str] = Field(..., min_length=8, max_length=14)
    experience: List[Experience] = Field(..., min_length=2, max_length=4)
    education: Education


class CV(BaseModel):
    """Schema for a complete CV including identity + technical details."""
    name: str
    email: EmailStr
    phone: str
    location: str
    role: str
    skills: List[str]
    experience: List[Experience]
    education: Education


# ---------------- LLM Agent ----------------
cv_agent = Agent(
    name="cv-tech-generator",
    model=MODEL,
    instructions=(
        "Complete ONLY the technical part of a *tech* CV in English. "
        "Output must match the CVTech schema. "
        "experience: 2–4 jobs, newest first; newest has end='Present'. "
        "Descriptions: 2–3 concise, measurable sentences. "
        "Skills: 8–14, relevant to role. "
        "Date format: 'Month YYYY'."
    ),
    output_type=CVTech,
)


# ---------------- PDF Styles (cached) ----------------
def get_styles():
    """
    Define and return reusable PDF text styles (title, subtitle, headings, body).
    """
    s = getSampleStyleSheet()
    title = ParagraphStyle(
        'Title',
        parent=s['Heading1'],
        fontSize=24,
        textColor=colors.HexColor('#3949ab'),
        alignment=1,
    )
    subtitle = ParagraphStyle(
        'Subtitle',
        parent=s['Normal'],
        fontSize=11,
        textColor=colors.grey,
        alignment=1,
    )
    heading = ParagraphStyle(
        'Heading',
        parent=s['Heading2'],
        fontSize=13.5,
        textColor=colors.HexColor('#3949ab'),
        spaceAfter=6,
        spaceBefore=10,
    )
    body = s['Normal']
    body.leading = 14

    return title, subtitle, heading, body


# ---------------- Utilities ----------------
def create_identity() -> CV:
    """
    Create a fixed identity that the LLM MUST NOT alter.
    This provides personal info (name, email, phone, location) while keeping
    the technical CV details empty for the agent to fill.
    """
    return CV(
        name=fake.name(),
        email=fake.email(),
        phone=fake.phone_number(),
        location=f"{fake.city()}, {fake.country()}",
        role="", skills=[], experience=[],
        education=Education(degree="", university="", year=2010),
    )


def make_prompt(cv_identity: CV) -> str:
    """
    Build the LLM prompt including:
    - Fixed candidate identity
    - Randomized constraints for diversity (career level, industry, stack)
    """
    level = random.choice(LEVELS)
    industry = random.choice(INDUSTRIES)
    primary_stack = random.choice(PRIMARY_STACKS)

    return (
        "You are completing ONLY the technical part of this CV (identity is fixed):\n"
        f"- Name: {cv_identity.name}\n"
        f"- Email: {cv_identity.email}\n"
        f"- Phone: {cv_identity.phone}\n"
        f"- Location: {cv_identity.location}\n\n"
        "Constraints & diversity:\n"
        f"- Career level: {level}\n"
        f"- Primary industry: {industry}\n"
        f"- Emphasize stack: {primary_stack}\n\n"
        "Return ONLY the CVTech object."
    )


def render_pdf(cv: CV, pdf_path: Path, avatar_path: Path | None):
    """
    Render a CV object into a styled PDF file, optionally including an avatar.
    """
    pdf_path.parent.mkdir(parents=True, exist_ok=True)
    doc = SimpleDocTemplate(str(pdf_path), pagesize=A4, topMargin=0.5 * inch, bottomMargin=0.5 * inch)
    title, subtitle, heading, body = get_styles()
    story = []

    if avatar_path and avatar_path.exists():
        img = RLImage(str(avatar_path), width=1.2 * inch, height=1.2 * inch)
        img.hAlign = "LEFT"
        story.append(img)

    story += [
        Paragraph(cv.name, title),
        Paragraph(cv.role, subtitle) if cv.role else Spacer(1, 0.01 * inch),
        Paragraph(f"{cv.email} | {cv.phone} | {cv.location}", subtitle),
        Spacer(1, 0.25 * inch),
        Paragraph("SKILLS", heading),
        Paragraph(" • ".join(cv.skills), body),
        Spacer(1, 0.15 * inch),
        Paragraph("EXPERIENCE", heading),
    ]

    for e in cv.experience:
        story += [
            Paragraph(f"<b>{e.role}</b> — {e.company}", body),
            Paragraph(f"<i>{e.start} – {e.end}</i>", body),
            Paragraph(e.description, body),
            Spacer(1, 0.1 * inch),
        ]

    story += [
        Paragraph("EDUCATION", heading),
        Paragraph(f"<b>{cv.education.degree}</b>", body),
        Paragraph(cv.education.university, body),
        Paragraph(f"Graduated: {cv.education.year}", body),
    ]

    doc.build(story)


async def generate_cv():
    """
    Orchestrate the full CV generation process:
    1. Create fake identity (not editable by LLM).
    2. Generate technical CV details via LLM.
    3. Merge identity + technical info into final CV.
    4. Generate avatar image.
    5. Render the CV into a PDF file.
    """
    identity = create_identity()
    prompt = make_prompt(identity)
    res = await Runner.run(cv_agent, prompt)
    cv_tech = res.final_output
    final_cv = CV(
        name=identity.name,
        email=identity.email,
        phone=identity.phone,
        location=identity.location,
        role=cv_tech.role,
        skills=cv_tech.skills,
        experience=cv_tech.experience,
        education=cv_tech.education,
    )

    slugged_name = slugify(final_cv.name)
    avatar_file = generate_avatar(final_cv.name)
    avatar_path = Path(avatar_file) if avatar_file else None

    pdf_path = CVS_OUTPUT_DIR / f"cv_{slugged_name}.pdf"
    await asyncio.to_thread(render_pdf, final_cv, pdf_path, avatar_path)

    return pdf_path


if __name__ == "__main__":
    try:
        asyncio.run(generate_cv())
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
